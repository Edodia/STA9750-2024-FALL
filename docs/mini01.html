<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Transit analysis – STA 9750 2024 Submission Material</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">STA 9750 2024 Submission Material</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Transit analysis</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>This document analyzes transit systems, including Fare Revenues, Expenses, Vehicle Revenue Miles (VRM), and Unlinked Passenger Trips (UPT). We will use various joined datasets to derive insights such as the transit system with the highest farebox recovery ratio, the one with the lowest expenses per VRM, and more. The main question that will be answered is what is the most efficient transit system.</p>
</section>
<section id="install.packagesdevtools" class="level1">
<h1>install.packages(“devtools”)</h1>
<p>if(!require(“tidyverse”)) install.packages(“tidyverse”)</p>
</section>
<section id="lets-start-with-fare-revenue" class="level1">
<h1>Let’s start with Fare Revenue</h1>
<p>library(tidyverse) if(!file.exists(“2022_fare_revenue.xlsx”)){ # This should work <em>in theory</em> but in practice it’s still a bit finicky # If it doesn’t work for you, download this file ‘by hand’ in your # browser and save it as “2022_fare_revenue.xlsx” in your project # directory. download.file(“http://www.transit.dot.gov/sites/fta.dot.gov/files/2024-04/2022%20Fare%20Revenue.xlsx”, destfile=“2022_fare_revenue.xlsx”, quiet=FALSE, method=“wget”) } FARES &lt;- readxl::read_xlsx(“2022_fare_revenue.xlsx”) |&gt; select(-<code>State/Parent NTD ID</code>, -<code>Reporter Type</code>, -<code>Reporting Module</code>, -<code>TOS</code>, -<code>Passenger Paid Fares</code>, -<code>Organization Paid Fares</code>) |&gt; filter(<code>Expense Type</code> == “Funds Earned During Period”) |&gt; select(-<code>Expense Type</code>) |&gt; group_by(<code>NTD ID</code>, # Sum over different <code>TOS</code> for the same <code>Mode</code> <code>Agency Name</code>, # These are direct operated and sub-contracted <code>Mode</code>) |&gt; # of the same transit modality # Not a big effect in most munis (significant DO # tends to get rid of sub-contractors), but we’ll sum # to unify different passenger experiences summarize(<code>Total Fares</code> = sum(<code>Total Fares</code>)) |&gt; ungroup()</p>
</section>
<section id="next-expenses" class="level1">
<h1>Next, expenses</h1>
<p>if(!file.exists(“2022_expenses.csv”)){ # This should work <em>in theory</em> but in practice it’s still a bit finicky # If it doesn’t work for you, download this file ‘by hand’ in your # browser and save it as “2022_expenses.csv” in your project # directory. download.file(“https://data.transportation.gov/api/views/dkxx-zjd6/rows.csv?date=20231102&amp;accessType=DOWNLOAD&amp;bom=true&amp;format=true”, destfile=“2022_expenses.csv”, quiet=FALSE) } EXPENSES &lt;- readr::read_csv(“2022_expenses.csv”) |&gt; select(<code>NTD ID</code>, <code>Agency</code>, <code>Total</code>, <code>Mode</code>) |&gt; mutate(<code>NTD ID</code> = as.integer(<code>NTD ID</code>)) |&gt; rename(Expenses = Total) |&gt; group_by(<code>NTD ID</code>, <code>Mode</code>) |&gt; summarize(Expenses = sum(Expenses)) |&gt; ungroup()</p>
<p>FINANCIALS &lt;- inner_join(FARES, EXPENSES, join_by(<code>NTD ID</code>, <code>Mode</code>))</p>
<p># Monthly Transit Numbers library(tidyverse) if(!file.exists(“ridership.xlsx”)){ # This should work <em>in theory</em> but in practice it’s still a bit finicky # If it doesn’t work for you, download this file ‘by hand’ in your # browser and save it as “ridership.xlsx” in your project # directory. download.file(“https://www.transit.dot.gov/sites/fta.dot.gov/files/2024-09/July%202024%20Complete%20Monthly%20Ridership%20%28with%20adjustments%20and%20estimates%29_240903.xlsx”, destfile=“ridership.xlsx”, quiet=FALSE) } TRIPS &lt;- readxl::read_xlsx(“ridership.xlsx”, sheet=“UPT”) |&gt; filter(<code>Mode/Type of Service Status</code> == “Active”) |&gt; select(-<code>Legacy NTD ID</code>, -<code>Reporter Type</code>, -<code>Mode/Type of Service Status</code>, -<code>UACE CD</code>, -<code>TOS</code>) |&gt; pivot_longer(-c(<code>NTD ID</code>:<code>3 Mode</code>), names_to=“month”, values_to=“UPT”) |&gt; drop_na() |&gt; mutate(month=my(month)) # Parse _m_onth _y_ear date specs MILES &lt;- readxl::read_xlsx(“ridership.xlsx”, sheet=“VRM”) |&gt; filter(<code>Mode/Type of Service Status</code> == “Active”) |&gt; select(-<code>Legacy NTD ID</code>, -<code>Reporter Type</code>, -<code>Mode/Type of Service Status</code>, -<code>UACE CD</code>, -<code>TOS</code>) |&gt; pivot_longer(-c(<code>NTD ID</code>:<code>3 Mode</code>), names_to=“month”, values_to=“VRM”) |&gt; drop_na() |&gt; group_by(<code>NTD ID</code>, <code>Agency</code>, <code>UZA Name</code>, <code>Mode</code>, <code>3 Mode</code>, month) |&gt; summarize(VRM = sum(VRM)) |&gt; ungroup() |&gt; mutate(month=my(month)) # Parse _m_onth _y_ear date specs</p>
<p>USAGE &lt;- inner_join(TRIPS, MILES) |&gt; mutate(<code>NTD ID</code> = as.integer(<code>NTD ID</code>)) # Create table if(!require(“DT”)) install.packages(“DT”) library(DT)</p>
<p>sample_n(USAGE, 1000) |&gt; mutate(month=as.character(month)) |&gt; DT::datatable() #Rename column USAGE &lt;- USAGE |&gt; rename(metro_area = <code>UZA Name</code>) head(USAGE) #Viewing Unique Mode Codes head(USAGE) #Clarifying codes USAGE &lt;- USAGE |&gt; mutate(<code>Mode</code> = case_when( <code>Mode</code> == “HR” ~ “Heavy Rail”, <code>Mode</code> == “DR” ~ “Demand Response”, <code>Mode</code> == “FB” ~ “Ferryboat”, <code>Mode</code> == “MB” ~ “Bus”, <code>Mode</code> == “SR” ~ “Streetcar Rail”, <code>Mode</code> == “TB” ~ “Trolleybus”, <code>Mode</code> == “VP” ~ “Vanpool”, <code>Mode</code> == “CB” ~ “Commuter Bus”, <code>Mode</code> == “RB” ~ “Bus Rapid Transit”, <code>Mode</code> == “LR” ~ “Light Rail”, <code>Mode</code> == “YR” ~ “Hybrid Rail”, <code>Mode</code> == “MG” ~ “Monorail Automated Guideway”, <code>Mode</code> == “CR” ~ “Commuter Rail”, <code>Mode</code> == “AR” ~ “Alaska Railroad”, <code>Mode</code> == “TR” ~ “Aerial Tramway”, <code>Mode</code> == “IP” ~ “Inclined Plane”, <code>Mode</code> == “PB” ~ “Publico”, <code>Mode</code> == “CC” ~ “Cable Car”, TRUE ~ “UNKOWN” )) #Checking answers head(USAGE) #Making table # Install and load DT package if necessary</p>
</section>
<section id="apply-the-transformation-and-create-the-datatable-with-server-side-processing" class="level1">
<h1>Apply the transformation and create the datatable with server-side processing</h1>
<p>if(!require(“DT”)) install.packages(“DT”) library(DT)</p>
</section>
<section id="apply-the-transformation-and-create-the-datatable-with-server-side-processing-1" class="level1">
<h1>Apply the transformation and create the datatable with server-side processing</h1>
<p>if(!require(“DT”)) install.packages(“DT”) library(DT)</p>
<p>sample_n(USAGE, 1000) |&gt; mutate(month=as.character(month)) |&gt; DT::datatable() #TASK 3 #QUEST|ON 1 : MTA New York City Transit 10832855350 USAGE |&gt; group_by(Agency) |&gt;<br>
summarize(total_VRM = sum(VRM, na.rm = TRUE)) |&gt; arrange(desc(total_VRM)) |&gt;<br>
slice(1)<br>
#Question 2 : BUS USAGE |&gt; group_by(Mode) |&gt;<br>
summarize(total_VRM = sum(VRM, na.rm = TRUE)) |&gt;<br>
arrange(desc(total_VRM)) |&gt;<br>
slice(1) #QUESTION 3 : Total trips in May 2024 is 16 # Note: Lubridate is usefulf for extracting info out of dates in that format if(!require(“lubridate”)) install.packages(“lubridate”) library(“lubridate”)</p>
<p>USAGE |&gt; mutate(date = as.Date(month, format = “%Y-%m-%d”)) |&gt;<br>
filter(<code>Mode</code> == “Heavy Rail”, year(date) == 2024, month(date) == 05) |&gt;<br>
summarize(total_trips = n())</p>
<p>#Question 5 : There is no fall in ttl ridership if(!require(“lubridate”)) install.packages(“lubridate”) library(“lubridate”) USAGE |&gt; mutate(date = as.Date(month, format = “%Y-%m-%d”)) |&gt; filter(<code>Mode</code> == “Heavy Rail”, month(date) == 4, year(date) %in% c(2019, 2020)) |&gt;<br>
group_by(year = year(date)) |&gt;<br>
summarize(total_ridership = n()) |&gt;<br>
summarize(fall = total_ridership[year == 2019] - total_ridership[year == 2020])<br>
#Who had the least VRM : Barnegat Bay Decoy &amp; Baymen’s Museum USAGE |&gt; group_by(Agency) |&gt;<br>
summarize(total_VRM = sum(VRM, na.rm = TRUE)) |&gt;<br>
arrange(total_VRM) |&gt;<br>
slice(1) #What transit mode had the least total VRM in our data set? : Aerial Tramway USAGE |&gt; group_by(Mode) |&gt;<br>
summarize(total_VRM = sum(VRM, na.rm = TRUE)) |&gt;<br>
arrange(total_VRM) |&gt;<br>
slice(1) #What is the average VRM for the NYC subway: 3639622 USAGE |&gt; filter(<code>Mode</code> == “Heavy Rail”) |&gt;<br>
summarize(average_VRM = mean(VRM, na.rm = TRUE)) #What is the agency with the highest VRM growth from 2019 to 2022 : Golden Crescent Regional Planning Commission USAGE |&gt; mutate(year = year(as.Date(month, format = “%Y-%m-%d”))) |&gt; filter(year %in% c(2019, 2020)) |&gt;<br>
group_by(Agency, year) |&gt;<br>
summarize(total_VRM = sum(VRM, na.rm = TRUE)) |&gt;<br>
spread(key = year, value = total_VRM) |&gt;<br>
mutate(growth = (<code>2020</code> - <code>2019</code>) / <code>2019</code> * 100) |&gt;<br>
arrange(desc(growth)) #Task 5 USAGE_2022_ANNUAL &lt;- USAGE |&gt; mutate(date = as.Date(month, format = “%Y-%m-%d”),<br>
year = year(date)) |&gt;<br>
filter(year == 2022) |&gt;<br>
group_by(<code>NTD ID</code>, Agency, metro_area, Mode) |&gt;<br>
summarize( total_UPT = sum(UPT, na.rm = TRUE),<br>
total_VRM = sum(VRM, na.rm = TRUE)<br>
) |&gt; ungroup()</p>
<p>FINANCIALS &lt;- FINANCIALS |&gt; mutate(<code>Mode</code> = case_when( <code>Mode</code> == “HR” ~ “Heavy Rail”, <code>Mode</code> == “DR” ~ “Demand Response”, <code>Mode</code> == “FB” ~ “Ferryboat”, <code>Mode</code> == “MB” ~ “Bus”, <code>Mode</code> == “SR” ~ “Streetcar Rail”, <code>Mode</code> == “TB” ~ “Trolleybus”, <code>Mode</code> == “VP” ~ “Vanpool”, <code>Mode</code> == “CB” ~ “Commuter Bus”, <code>Mode</code> == “RB” ~ “Bus Rapid Transit”, <code>Mode</code> == “LR” ~ “Light Rail”, <code>Mode</code> == “YR” ~ “Hybrid Rail”, <code>Mode</code> == “MG” ~ “Monorail Automated Guideway”, <code>Mode</code> == “CR” ~ “Commuter Rail”, <code>Mode</code> == “AR” ~ “Alaska Railroad”, <code>Mode</code> == “TR” ~ “Aerial Tramway”, <code>Mode</code> == “IP” ~ “Inclined Plane”, <code>Mode</code> == “PB” ~ “Publico”, <code>Mode</code> == “CC” ~ “Cable Car”, TRUE ~ “UNKOWN”))</p>
<p>USAGE_AND_FINANCIALS &lt;- left_join(USAGE_2022_ANNUAL, FINANCIALS, join_by(<code>NTD ID</code>, Mode)) |&gt; drop_na()</p>
<p>if(!require(“DT”)) install.packages(“DT”) library(DT)</p>
<p>sample_n(USAGE_AND_FINANCIALS, 1000) |&gt; DT::datatable() #Question 1 : MTA Heavy Rail USAGE_AND_FINANCIALS |&gt; arrange(desc(total_UPT)) |&gt;<br>
slice(1)<br>
#Question 2 : Vanpool, Transit Authority of Central Kentucky USAGE_AND_FINANCIALS |&gt; mutate(farebox_recovery_ratio = <code>Total Fares</code> / Expenses) |&gt;<br>
arrange(desc(farebox_recovery_ratio)) |&gt;<br>
slice(1) #Question 3 : North Carolina State University, Bus USAGE_AND_FINANCIALS |&gt; mutate(expenses_per_UPT = Expenses / total_UPT) |&gt; arrange(expenses_per_UPT) |&gt;<br>
slice(1) #Question 4 : Altoona Metro Transit, Demand Response USAGE_AND_FINANCIALS |&gt; mutate(fares_per_UPT = <code>Total Fares</code> / total_UPT) |&gt;<br>
arrange(desc(fares_per_UPT)) |&gt;<br>
slice(1) # Question 5 : New Mexico Department of Transportation, vanpool USAGE_AND_FINANCIALS |&gt; mutate(expenses_per_VRM = Expenses / total_VRM) |&gt;<br>
arrange(expenses_per_VRM) |&gt;<br>
slice(1) #Question 6 : ferryboat, Chicago Water Taxi (Wendella) USAGE_AND_FINANCIALS |&gt; mutate(fares_per_VRM = <code>Total Fares</code> / total_VRM) |&gt;<br>
arrange(desc(fares_per_VRM)) |&gt;<br>
slice(1) #Bonus Question: Which transit system (agency and mode) #had the highest farebox recovery, defined as the highest ratio # of Total Fares to Expenses? # per 400,000 UPT? USAGE_AND_FINANCIALS |&gt; Altoona Metro Transit, Demand Response mutate(farebox_recovery_ratio_big = (<code>Total Fares</code> / Expenses) * (400000 / total_UPT)) |&gt;<br>
arrange(desc(farebox_recovery_ratio_big)) |&gt;<br>
slice(1)</p>
<p>#Final Answer</p>
<p>It seeems that Altoona Metro Transit within Demand Response transportation is the most effecient financially out of all transit systems big or small. This makes sense considering that the MTA despite having a huge ridership base is very ineffecient financially. This is publically known and fare evasion may be huge contributor to this problem.</p>
<hr>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/<Edodia>\.github\.io\/STA9750-2024-FALL\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>